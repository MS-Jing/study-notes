## 静态代理

角色分析：

+ 抽象角色 ：一般会使用接口或者抽象类来解决
+ 真实角色：被代理的角色
+ 代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作
+ 客户：访问代理对象的人

静态代理模式的好处：

+ 可以使真实角色的操作更加纯粹! 不用去关注一些公共的业务
+ 公共也就是交给代理角色！实现了业务的分工！
+ 公共业务发生扩展的时候，方便集中管理！

缺点：

+ 一个真实角色就会产生一个代理角色；代码量会翻倍，开发效率会变低

## 动态代理

+ 动态代理和静态代理角色一样
+ 动态代理的代理类是动态生成的，不是我们直接写好的!
+ 动态代理分为两大类:基于接口的动态代理，基于类的动态代理
  + 基于接口--- JDK动态代理[我们在这里使用]
  + 基于类: cglib
  + java字节码实现: javasist

需要了解两个类：proxy：代理，InvocationHandler：调用处理程序



动态代理的好处：

+ 可以使真实角色的操作更加纯粹! 不用去关注一些公共的业务
+ 公共也就是交给代理角色！实现了业务的分工！
+ 公共业务发生扩展的时候，方便集中管理！
+ 一个动态代理类代理的就是一个接口，一般就是对应的一类业务
+ 一个动态代理类可以代理多个类，只要是实现了同一个接口

```java
/**
 * @author luojing
 * @create 2021/4/6
 */
public class ProInvocationHander implements InvocationHandler {

    private Rent rent;

    public void setRent(Rent rent) {
        this.rent = rent;
    }

    //获取要租房的代理
    public Rent getProxy(){
        return (Rent) Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this);
    }

    //根据代理的去执行方法
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("===========");
        Object invoke = method.invoke(rent, args);
        System.out.println("-----------");
        return invoke;
    }
}
```

