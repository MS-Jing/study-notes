# 在Maven未出现前的问题

+ #### jar包难以寻找

+ #### jar包依赖的问题

+ #### jar包版本冲突问题

+ #### jar不方便管理

+ #### 项目结构五花八门

+ #### 项目的生命周期控制方式五花八门

# 约定配置

 Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，我们尽可能的遵守这样的目录结构 

| 目录                            | 目的                           |
| ------------------------------- | ------------------------------ |
| ${base}                         | 存放pom.xml及所有子目录        |
| ${base}/src/main/java           | 项目的java源代码               |
| ${base}/src/main/resources      | 项目资源目录                   |
| ${base}/src/main/webapp/WEB-INF | web应用文件目录，web项目的信息 |
| ${base}/src/test/java           | 项目测试类                     |
| ${base}/src/test/resources      | 测试用的资源                   |
| ${base}/target                  | 打包输出目录                   |
| ${base}/target/classes          | 编译输出目录                   |
| ${base}/target/test-classes     | 测试编译输出目录               |

# POM文件

 POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构件，声明项目依赖，等等。 

POM 中可以指定以下配置：

- 项目依赖
- 插件
- 执行目标
- 项目构件 profile
- 项目版本
- 项目开发者列表
- 相关邮件列表信息

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- 模型版本 -->
    <modelVersion>4.0.0</modelVersion>

    <!-- 定义当前构件所属的组，通常与域名反向一一对应 -->
    <groupId>com.javacode2018</groupId>
    <!--项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的-->
    <artifactId>maven-chat02</artifactId>

    <!-- 版本号 -->
    <version>1.0-SNAPSHOT</version>

</project>
```

## Maven坐标

 maven中引入了坐标的概念，每个构件都有唯一的坐标，我们使用maven创建一个项目需要标注其坐标信息，而项目中用到其他的一些构件，也需要知道这些构件的坐标信息。 

```xml
<groupId>com.javacode2018</groupId>
<artifactId>springboot-chat01</artifactId>
<version>0.0.1-SNAPSHOT</version>
<packaging>jar</packaging>
```

> goupId：定义当前构件所属的组，通常与域名反向一一对应。
>
> artifactId：项目组中构件的编号。
>
> version：当前构件的版本号，每个构件可能会发布多个版本，通过版本号来区分不同版本的构件。
>
> package：定义该构件的打包方式，比如我们需要把项目打成jar包，采用`java -jar`去运行这个jar包，那这个值为jar；若当前是一个web项目，需要打成war包部署到tomcat中，那这个值就是war，可选（jar、war、ear、pom、maven-plugin），比较常用的是jar、war、pom

## 导入依赖

```xml
<dependencies>
    <!-- 在这里添加你的依赖 -->
    <dependency>
        <groupId></groupId>
        <artifactId></artifactId>
        <version></version>
        <type></type>
        <scope></scope>
        <optional></optional>
        <exclusions>
            <exclusion></exclusion>
            <exclusion></exclusion>
        </exclusions>
    </dependency>
</dependencies>
```

- type：依赖的类型，表示所要依赖的构件的类型，对应于被依赖的构件的packaging。大部分情况下，该元素不被声明，默认值为jar，表示被依赖的构件是一个jar包。
- scope：依赖的范围
- option：标记依赖是否可选
- exclusions：用来排除传递性的依赖

## maven依赖范围（scope）

 **maven用到classpath的地方有：编译源码、编译测试代码、运行测试代码、运行项目，这几个步骤都需要用到classpath。** 

 如上面的需求，编译、测试、运行需要的classpath对应的值可能是不一样的，这个maven中的scope为我们提供了支持，可以帮我们解决这方面的问题，scope是用来控制被依赖的构件与classpath的关系（编译、打包、运行所用到的classpath） 

+ compile

 编译依赖范围，如果没有指定，默认使用该依赖范围，**对于编译源码、编译测试代码、测试、运行4种classpath都有效** 

+ test

 测试依赖范围，使用此依赖范围的maven依赖，**只对编译测试、运行测试的classpath有效，在编译主代码、运行项目时无法使用此类依赖**。比如junit，它只有在编译测试代码及运行测试的时候才需要。 

+ provide

 已提供依赖范围。表示项目的运行环境中已经提供了所需要的构件，对于此依赖范围的maven依赖，**对于编译源码、编译测试、运行测试中classpath有效，但在运行时无效**。比如上面说到的servlet-api，这个在编译和测试的时候需要用到，但是在运行的时候，web容器已经提供了，就不需要maven帮忙引入了。 

+ runtime

 运行时依赖范围，使用此依赖范围的maven依赖，**对于编译测试、运行测试和运行项目的classpath有效，但在编译主代码时无效**，比如jdbc驱动实现，运行的时候才需要具体的jdbc驱动实现。 

+ system

 系统依赖范围，该依赖与3中classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显示的指定依赖文件的路径。这种依赖直接依赖于本地路径中的构件，可能每个开发者机器中构件的路径不一致，所以如果使用这种写法，你的机器中可能没有问题，别人的机器中就会有问题，所以建议谨慎使用。 

```xml
<dependency>
    <groupId>com.javacode2018</groupId>
    <artifactId>rt</artifactId>
    <version>1.8</version>
    <scope>system</scope>
    <systemPath>${java.home}/lib/rt.jar</systemPath>
</dependency>
```

| 依赖范围 | 编译源码 | 编译测试代码 | 运行测试 | 运行项目 | 案例        |
| -------- | -------- | ------------ | -------- | -------- | ----------- |
| compile  | y        | y            | y        | y        | spring-web  |
| test     |          | y            | y        |          | junit       |
| provide  | y        | y            | y        |          | servlet-api |
| runtime  |          | y            | y        | y        | jdbc驱动    |
| system   | y        | y            | y        |          | 本地jar     |

## 可选依赖（optional元素）

a依赖于b,b依赖于c,但是b不想让a依赖c：

 `dependency元素下面有个optional，是一个boolean值，表示是一个可选依赖`，B->C时将这个值置为true，那么C不会被A自动引入。 

## 排除依赖

```xml
<dependency>
    <groupId>com.javacode2018</groupId>
    <artifactId>B</artifactId>
    <version>1.0</version>
    <exclusions>
        <exclusion>
            <groupId>com.javacode2018</groupId>
            <artifactId>C</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

 上面使用使用exclusions元素排除了B->C依赖的传递，也就是B->C不会被传递到A中 



# Maven仓库

 **maven采用引用的方式将依赖的jar引入进来，不对真实的jar进行拷贝，但是打包的时候，运行需要用到的jar都会被拷贝到安装包中。** 

 在 Maven 中，仓库是一个位置，这个位置是用来存放各种第三方构件的，所有maven项目可以共享这个仓库中的构件。 



## 远程仓库的配置

**pom.xml中配置远程仓库**：

```xml
<repositories>
    <repository>
        <id>aliyun-releases</id>
        <url>https://maven.aliyun.com/repository/public</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
</repositories>
```

- id：远程仓库的一个标识，中央仓库的id是`central`，所以添加远程仓库的时候，id不要和中央仓库的id重复，会把中央仓库的覆盖掉
- url：远程仓库地址
- releases：主要用来配置是否需要从这个远程仓库下载稳定版本构建
- snapshots：主要用来配置是否需要从这个远程仓库下载快照版本构建



**镜像的方式**：

在settings.xml中配置

```xml
<mirror>
  <id>mirrorId</id>
  <mirrorOf>repositoryId</mirrorOf>
  <name>Human Readable Name for this Mirror.</name>
  <url>http://my.repository.com/repo/path</url>
</mirror>
```

- id：镜像的id，是一个标识
- name：镜像的名称，这个相当于一个描述信息，方便大家查看
- url：镜像对应的远程仓库的地址
- mirrorOf：指定哪些远程仓库的id使用这个镜像，这个对应pom.xml文件中repository元素的id，就是表示这个镜像是给哪些pom.xml文章中的远程仓库使用的，这里面需要列出远程仓库的id，多个之间用逗号隔开，`*`表示给所有远程仓库做镜像



# 生命周期

 我们开发一个项目的时候，通常有这些环节：创建项目、编写代码、清理已编译的代码、编译代码、执行单元测试、打包、集成测试、验证、部署、生成站点等，这些环节组成了项目的生命周期，这些过程也叫做项目的**构建过程**，几乎所有的项目都由这些环节中的其中几个，创建项目和编写代码是我们程序员需要多参与的，其他的都可以做成自动化的方式。 

maven出来之后，项目生命周期中的这些环节都被简化了，被规范化了，maven出现之前，项目的结构没有一个统一的标准，所以生命周期中各个环节对应的自动化脚本也是各种各样，而maven约定好了项目的结构，源码的位置、资源文件的位置、测试代码的位置、测试用到的资源文件的位置、静态资源的位置、打包之后文件的位置等，这些都是maven约定好的，所以清理代码用一个命令`mvn clean`就可以完成，不需要我们去配置清理的目标目录；用`mvn compile`命令就可以完成编译的操作；用`mvn test`就可以自动运行测试用例；用`mvn package`就可以将项目打包为`jar、war`格式的包，能够如此简单，主要还是maven中约定大于配置的结果。 

 maven将项目的生命周期抽象成了3套生命周期，每套生命周期又包含多个阶段，每套中具体包含哪些阶段是maven已经约定好的，但是每个阶段具体需要做什么，是用户可以自己指定的。 

1. **clean生命周期**
2. **default生命周期**
3. **site生命周期**

## clean生命周期

 clean生命周期的目的是清理项目 

| 生命周期阶段 | 描述                                  |
| :----------- | :------------------------------------ |
| pre-clean    | 执行一些需要在clean之前完成的工作     |
| clean        | 移除所有上一次构建生成的文件          |
| post-clean   | 执行一些需要在clean之后立刻完成的工作 |

用户可以通过`mvn pre-clean`来调用clean生命周期中的`pre-clean`阶段需要执行的操作。

调用`mvn post-clean`会执行上面3个阶段所有的操作，上文中有说过，每个生命周期中的后面的阶段会依赖于前面的阶段，当执行某个阶段的时候，会先执行其前面的阶段。

## default生命周期

 这个是maven主要的生命周期，主要被用于构建应用 

| 生命周期阶段            | 描述                                                         |
| :---------------------- | :----------------------------------------------------------- |
| validate                | 校验：校验项目是否正确并且所有必要的信息可以完成项目的构建过程。 |
| initialize              | 初始化：初始化构建状态，比如设置属性值。                     |
| generate-sources        | 生成源代码：生成包含在编译阶段中的任何源代码。               |
| process-sources         | 处理源代码：处理源代码，比如说，过滤任意值。                 |
| generate-resources      | 生成资源文件：生成将会包含在项目包中的资源文件。             |
| process-resources       | 编译：复制和处理资源到目标目录，为打包阶段做好准备。         |
| compile                 | 处理类文件：编译项目的源代码。                               |
| process-classes         | 处理类文件：处理编译生成的文件，比如说对Java class文件做字节码改善优化。 |
| generate-test-sources   | 生成测试源代码：生成包含在编译阶段中的任何测试源代码。       |
| process-test-sources    | 处理测试源代码：处理测试源代码，比如说，过滤任意值。         |
| generate-test-resources | 生成测试源文件：为测试创建资源文件。                         |
| process-test-resources  | 处理测试源文件：复制和处理测试资源到目标目录。               |
| test-compile            | 编译测试源码：编译测试源代码到测试目标目录.                  |
| process-test-classes    | 处理测试类文件：处理测试源码编译生成的文件。                 |
| test                    | 测试：使用合适的单元测试框架运行测试（Juint是其中之一）。    |
| prepare-package         | 准备打包：在实际打包之前，执行任何的必要的操作为打包做准备。 |
| package                 | 打包：将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。 |
| pre-integration-test    | 集成测试前：在执行集成测试前进行必要的动作。比如说，搭建需要的环境。 |
| integration-test        | 集成测试：处理和部署项目到可以运行集成测试环境中。           |
| post-integration-test   | 集成测试后：在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。 |
| verify                  | 验证：运行任意的检查来验证项目包有效且达到质量标准。         |
| install                 | 安装：安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。 |
| deploy                  | 部署：将最终的项目包复制到远程仓库中与其他开发者和项目共享。 |

## site生命周期

 site生命周期的目的是建立和发布项目站点，Maven能够基于pom.xml所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。主要包含以下4个阶段：

| 阶段        | 描述                                                       |
| :---------- | :--------------------------------------------------------- |
| pre-site    | 执行一些需要在生成站点文档之前完成的工作                   |
| site        | 生成项目的站点文档                                         |
| post-site   | 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 |
| site-deploy | 将生成的站点文档部署到特定的服务器上                       |

## mvn命令和生命周期

 从命令行执行maven任务的最主要方式就是调用maven生命周期的阶段，需要注意的是，每套生命周期是相互独立的，但是每套生命周期中阶段是有前后依赖关系的，执行某个的时候，会按序先执行其前面所有的。 

mvn执行阶段的命令格式是：

```
mvn 阶段1 [阶段2] [阶段n]
```

> 多个阶段的名称之间用空格隔开。

常见的例子：

 **mvn clean**

该命令是调用clean生命周期的clean阶段，实际执行的阶段为clean生命周期中的pre-clean和clean阶段。

 **mvn test**

该命令调用default生命周期的test阶段，实际上会从default生命周期的第一个阶段（`validate`）开始执行一直到`test`阶段结束。这里面包含了代码的编译，运行测试用例。

 **mvn clean install**

这个命令中执行了两个阶段：`clean`和`install`，从上面3个生命周期的阶段列表中找一下，可以看出`clean`位于`clean`生命周期的表格中，`install`位于`default`生命周期的表格中，所以这个命令会先从`clean`生命周期中的`pre-clean`阶段开始执行一直到`clean`生命周期的`clean`阶段；然后会继续从`default`生命周期的`validate`阶段开始执行一直到default生命周期的`install`阶段。

这里面包含了清理上次构建的结果，编译代码，测试，打包，将打好的包安装到本地仓库。

# Maven插件

maven插件主要是为maven中生命周期中的阶段服务的，maven中只是定义了3套生命周期，以及每套生命周期中有哪些阶段，具体每个阶段中执行什么操作，完全是交给插件去干的。 

maven中的插件就相当于一些工具，比如编译代码的工具，运行测试用例的工具，打包代码的工具，将代码上传到本地仓库的工具，将代码部署到远程仓库的工具等等，这些都是maven中的插件。 

插件可以通过`mvn`命令的方式调用直接运行，或者将插件和maven生命周期的阶段进行绑定，然后通过`mvn 阶段`的方式执行阶段的时候，会自动执行和这些阶段绑定的插件。 

## 插件目标

maven中的插件以jar的方式存在于仓库中，和其他构件是一样的，也是通过坐标进行访问，每个插件中可能为了代码可以重用，一个插件可能包含了多个功能，比如编译代码的插件，可以编译源代码、也可以编译测试代码；**插件中的每个功能就叫做插件的目标（Plugin Goal），每个插件中可能包含一个或者多个插件目标（Plugin Goal）**。 

### 目标参数

 插件目标是用来执行任务的，那么执行任务肯定是有参数配的，这些就是目标的参数，每个插件目标对应于java中的一个类，参数就对应于这个类中的属性。 

### 列出插件所有目标

```base
mvn 插件goupId:插件artifactId[:插件version]:help
mvn 插件前缀:help
```

示例：

```
mvn org.apache.maven.plugins:maven-clean-plugin:help
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------< com.lj:webServer >--------------------------
[INFO] Building webServer 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.5:help (default-cli) @ webServer ---
[INFO] org.apache.maven.plugins:maven-clean-plugin:2.5

Maven Clean Plugin
  The Maven Clean Plugin is a plugin that removes files generated at build-time
  in a project's directory.

This plugin has 2 goals:

clean:clean
  Goal which cleans the build.
  This attempts to clean a project's working directory of the files that were
  generated at build-time. By default, it discovers and deletes the directories
  configured in project.build.directory, project.build.outputDirectory,
  project.build.testOutputDirectory, and project.reporting.outputDirectory.

  Files outside the default may also be included in the deletion by configuring
  the filesets tag.

clean:help
  Display help information on maven-clean-plugin.
  Call
    mvn clean:help -Ddetail=true -Dgoal=<goal-name>
  to display parameter details.


[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.348 s
[INFO] Finished at: 2021-07-22T15:26:13+08:00
[INFO] ------------------------------------------------------------------------
```

> 上面列出了`maven-clean-plugin`这个插件所有的目标，有2个，分别是`clean:clean、clean:help`，分号后面的部分是目标名称，分号前面的部分是插件的前缀，每个目标的后面包含对这个目标的详细解释说明

### 查看插件目标参数列表

```
mvn 插件goupId:插件artifactId[:插件version]:help -Dgoal=目标名称 -Ddetail
mvn 插件前缀:help -Dgoal=目标名称 -Ddetail
```

> 上面命令中的`-Ddetail`用户输出目标详细的参数列表信息，如果没有这个，目标的参数列表不会输出出来，看效果。

示例：

```base
mvn org.apache.maven.plugins:maven-clean-plugin:help -Dgoal=help -Ddetail
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------< com.lj:webServer >--------------------------
[INFO] Building webServer 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.5:help (default-cli) @ webServer ---
[INFO] org.apache.maven.plugins:maven-clean-plugin:2.5

Maven Clean Plugin
  The Maven Clean Plugin is a plugin that removes files generated at build-time
  in a project's directory.

clean:help
  Display help information on maven-clean-plugin.
  Call
    mvn clean:help -Ddetail=true -Dgoal=<goal-name>
  to display parameter details.

  Available parameters:

    detail (Default: false)
      If true, display all settable properties for each goal.
      Expression: ${detail}

    goal
      The name of the goal for which to show help. If unspecified, all goals
      will be displayed.
      Expression: ${goal}

    indentSize (Default: 2)
      The number of spaces per indentation level, should be positive.
      Expression: ${indentSize}

    lineLength (Default: 80)
      The maximum length of a display line, should be positive.
      Expression: ${lineLength}


[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.342 s
[INFO] Finished at: 2021-07-22T15:29:59+08:00
[INFO] ------------------------------------------------------------------------
```

 注意上面参数详细参数说明中有`Expression: ${xxx}`这样的部分，这种表示给这个运行的目标传参，可以通过`mvn -Dxxx`这种方式传参，`xxx`为`${xxx}`中的`xxx`部分，这个`xxx`有时候和目标参数的名称不一致，所以这点需要注意，运行带参数的目标 

### 命令行运行插件

```bash
mvn 插件goupId:插件artifactId[:插件version]:插件目标 [-D目标参数1] [-D目标参数2] [-D目标参数n]
mvn 插件前缀:插件目标  [-D目标参数1] [-D目标参数2] [-D目标参数n]
```

#### 插件传参的2种方式

 除了通过`-D`后面跟用户属性的方式给用户传参，还有一种方式，在pom.xml中`properties`的用户自定义属性中进行配置 

```xml
<maven.test.skip>true</maven.test.skip>
```

#### 获取插件目标详细描述信息的另外一种方式

```base
mvn help:describe -Dplugin=插件goupId:插件artifactId[:插件version] -Dgoal=目标名称 -Ddetail
mvn help:describe -Dplugin=插件前缀 -Dgoal=目标名称 -Ddetail
```

#### 插件前缀

 运行插件的时候，可以通过指定插件坐标的方式运行，但是插件的坐标信息过于复杂，也不方便写和记忆，所以maven中给插件定义了一些简捷的插件前缀，可以通过插件前缀来运行指定的插件。 

查看到插件的前缀：

```bash
mvn help:describe -Dplugin=插件goupId:插件artifactId[:插件version]
```

示例：

```bash
λ mvn help:describe -Dplugin=org.apache.maven.plugins:maven-surefire-plugin
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------< com.lj:webServer >--------------------------
[INFO] Building webServer 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-help-plugin:3.2.0:describe (default-cli) @ webServer ---
[INFO] org.apache.maven.plugins:maven-surefire-plugin:2.12.4

Name: Maven Surefire Plugin
Description: Surefire is a test framework project.
Group Id: org.apache.maven.plugins
Artifact Id: maven-surefire-plugin
Version: 2.12.4
Goal Prefix: surefire
```

>  输出中的`Goal Prefix:`部分对应的就是插件的前缀，上面这个插件的前缀是`surefire`。 



上面用了很多`mvn help:`这个命令，这个调用的是`maven-help-plugin`插件的功能，`help`是插件的前缀，它的坐标是：

```xml
<dependency>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-help-plugin</artifactId>
    <version>3.2.0</version>
</dependency>
```

## 插件和生命周期阶段绑定

 maven只是定义了生命周期中的阶段，而没有定义每个阶段中具体的实现，这些实现是由插件的目标来完成的，所以需要将阶段和插件目标进行绑定，来让插件目标帮助生命周期的阶段做具体的工作，生命周期中的每个阶段支持绑定多个插件的多个目标。 



 **当我们将生命周期中的阶段和插件的目标进行绑定的时候，执行`mvn 阶段`就可以执行和这些阶段绑定的`插件目标`。** 

## maven内置插件以及绑定

 maven为了让我们不用做任何配置就可以实现一些项目的构建操作，比如运行`mvn clean`就可以帮我们清理代码，运行`mvn install`就可以将构件安装到本地仓库，所以maven帮我们做了一些事情，maven内部已经提供了很多默认的插件，而将一些阶段默认和这些插件阶段绑定好了，所以我们不用做任何配置就可以执行清理代码、编译代码、测试、打包、安装到本地仓库、上传到远程仓库等阶段的操作，是因为maven已经默认给这些阶段绑定好了插件目标，所以不需要我们再去配置，就直接可以运行，这些都是maven内置绑定帮我们做的事情 

### maven内置绑定

**clean生命周期阶段与插件绑定关系**

| 生命周期阶段 | 插件:目标                |
| :----------- | :----------------------- |
| pre-clean    |                          |
| clean        | maven-clean-plugin:clean |
| post-clean   |                          |

>  clean周期中只有clean阶段默认绑定了`maven-clean-plugin`插件的`clean`目标。`maven-clean-plugin`插件的`clean`目标作用就是删除项目的输出目录。 

**default生命周期阶段与插件绑定关系**

| 生命周期阶段           | 插件:目标                            | 执行任务                       |
| :--------------------- | :----------------------------------- | :----------------------------- |
| process-resources      | maven-resources-plugin:resources     | 复制主资源文件至主输出目录     |
| compile                | maven-compiler-plugin:compile        | 编译主代码至主输出目录         |
| process-test-resources | maven-resources-plugin:testResources | 复制测试资源文件至测试输出目录 |
| test-compile           | maven-compiler-plugin:testCompile    | 编译测试代码至测试输出目录     |
| test                   | maven-surefile-plugin:test           | 执行测试用例                   |
| package                | maven-jar-plugin:jar                 | 创建项目jar包                  |
| install                | maven-install-plugin:install         | 将输出构件安装到本地仓库       |
| deploy                 | maven-deploy-plugin:deploy           | 将输出的构件部署到远程仓库     |

**site生命周期阶段与插件绑定关系**

| 生命周期阶段 | 插件:目标                |
| :----------- | :----------------------- |
| pre-site     |                          |
| site         | maven-site-plugin:site   |
| post-site    |                          |
| site-deploy  | maven-site-plugin:deploy |



### 自定义绑定







